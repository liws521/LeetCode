https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/

## 思路分析
- hard总不能每次都逃避, 加油, 试试
- 以10进制为一个界限, 分析一下出现规律
- 0-9中出现一次
- 0-99中一横一纵, 出现20次, 在个位上10次, 十位上10次
- 0-999中, 个位上100次, 十位上100次, 百位上100次
- 所以想知道一个数n中有多少个1, 得知道他处于哪个量级
- 比如输入了一个数字5482, 首先分为0-4999, 5000-5399, 5400-5479, 5480-5482
- 其中在四位数量级0-9999上, 各十百千位都会出现1000次,
- 千位的1000是只要大于0-1999就有了, 其他的位数是有几份就几百次
- 比如0-4999就会是1000+500+500+500, 一共2500个1
- 5000-5399, 100+40+40 = 180
- 5400-5479, 10+8=18
- 5480-5482, 1
- 一共2699, 通过程序验证成功, 接下来就是代码怎么写了
- 输入的范围为 1 <= n < 2^31 = 4_294_967_296
- 注意一个问题是对1的处理, 例如如果上面例子改为5182怎么处理
- 0-4999, 5000-5099, 5100-5179, 5180-5182
- 也就是如果正好卡在了1上, 要加上后面的这些值, 比如这里加个82,(是83, 还要5100)
- 2500+20+83+10+8+1 = 2622, 验证成功
- 接下来就是写代码了

## 代码实现
- 输入一个n, 先把它转化成string, 这样可以方便的统计这是一个几位数
- 然后取最高位进行处理, 以5182为例, 取出5, 并且知道这是一个len为4的字符串的最高位
- 计算0-4999, 因为5>1, 所以1000直接加, 然后因为里面有5份1000, 所以加5 * 100 * 3, 个十百三位
- 再取1, 此时len=3, 因为1==1, 所以加100里面的20个, 再加上后面的字符串转化为的数82+1
- 以此类推, 当取到一个0, 那直接跳过就行
```go
func countDigitOne(n int) int {
	res := 0
	s := fmt.Sprintf("%d", n)
	index := len(s) - 1
	base := 1
	for i := 0; i < index; i++ {
		base *= 10
	}
	for n != 0 {
		bit := n / base
		n %= base
		helper(bit, n, base, index, &res)
		base /= 10
		index--
	}
	return res
}

func helper(bit, n, base, index int, res *int) {
	if bit == 0 {
		return
	} else if bit == 1 {
		*res += n + 1
		*res += index * base / 10
		return
	} else {
		*res += base
		*res += index * bit * base / 10
		return
	}
}
```