https://leetcode-cn.com/problems/qiu-12n-lcof/

## 思路分析
- 不能使用乘除法, 求和公式不能用了
- 不能使用循环, 循环累加不能用了
- 不能使用条件判断, 递归不能用了(因为总要判断下递归边界)
- 位运算么, 是不是可以用位运算来模拟出求和公式
- n * (n + 1) / 2, 除以2就是右移1位, 考虑前面
- 如果能用循环, 那判断二进制位是1, 累加一下就可以了
- 但是不能用循环怎么办?
- 看题解
- 有没有办法去掉这个循环语句呢？答案是有的，那就是自己手动展开，因为题目数据范围 nn 为 [1,10000][1,10000]，所以 nn 二进制展开最多不会超过 1414 位，我们手动展开 1414 层代替循环即可
- ???
- 这emm, 不敢苟同


## 不用if判断边界的递归
- 通常实现递归的时候我们都会利用条件判断语句来决定递归的出口，但由于题目的限制我们不能使用条件判断语句，那么我们是否能使用别的办法来确定递归出口呢？答案就是逻辑运算符的短路性质。
- 以逻辑运算符 && 为例，对于 A && B 这个表达式，如果 A 表达式返回 False ，那么 A && B 已经确定为 False ，此时不会去执行表达式 B。同理，对于逻辑运算符 ||， 对于 A || B 这个表达式，如果 A 表达式返回 True ，那么 A || B 已经确定为True ，此时不会去执行表达式 B。
- 利用这一特性，我们可以将判断是否为递归的出口看作 A && B 表达式中的 A 部分，递归的主体函数看作 B 部分。如果不是递归出口，则返回 True，并继续执行表达式 B 的部分，否则递归结束。当然，你也可以用逻辑运算符 || 给出类似的实现，这里我们只提供结合逻辑运算符 && 的递归实现。
```c++
class Solution {
public:
    int sumNums(int n) {
        n && (n += sumNums(n-1));
        return n;
    }
};
```
- 太秀了, Golang实现的时候还得改改 , 因为Golang不能让0/非0当bool值
- 所以得重写个返回bool类型的递归函数
```go
func sumNums(n int) int {
    ans := 0
    var sum func(int) bool
    sum = func(n int) bool {
        ans += n
        return n > 0 && sum(n-1)
    }
    sum(n)
    return ans
}
```

- 在LeetCode里用Golang的全局变量真的不行
- 执行代码没问题, 一提交就各种数据错误
- 没做好, 不要使用全局变量了
- 从上面代码学到, 如果一个函数A只被B调用, 那完全可以
- 把A定义在B的内部, 这样B相对于A就是个全局的关系
```go
func sumNums(n int) int {
    ans := 0
    sum(n, &ans)
    return ans
}

func sum(n int, ans *int) bool {
    *ans += n
    return n > 0 && sum(n - 1, ans)
}
```