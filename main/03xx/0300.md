https://leetcode-cn.com/problems/longest-increasing-subsequence/

## 思路分析
- leetcode上对于subsequence的概念好像不要求连续呀, 只要顺序稳定就行
- 0, 1, 0, 3, 2, 3, 难度在于当碰到第一个3, 怎么知道这个不是, 后面的那个2, 3才是我们要的结果
- 好像不是一个能一遍O(n)解决的问题
- 我有点想回溯了, 好像用回溯这是个比较简单的问题, 就是不知道有没有比回溯复杂度低的方法
- 每一个元素弄一棵树, 碰到<=当前值的就剪枝, 记录最深层数是我们要的结果
- 这个最深层数也可以指导剪枝, 比如当前已经有长为4的路了, 长度达不到4的横向节点就可以剪枝了
- 确实复杂度比较高, 但现在除了回溯也想不出其他办法, 
- 再想想, 比如我第一个元素是0, 我就把后面<=0的都删掉, 这不合理, 等于的可以删掉, 因为一定没有更优解, <的删掉不合理, 因为是有可能产生从小于的节点起始的更优解, 所以等于也不能删, 因为它可能是小于节点的阶梯
- 例如 5, 6, 2, 5, 6, 如果第一个看到5, 就删掉, 这题就得不到答案为3的解了, 所以删是不行的
- 还是看0, 1, 0, 3, 2, 3的例子
- 0可以分出1, 0, 3, 2, 3这几个分支, 0分支可以根据<=删掉, 其实3, 2, 3都是可删的因为前面有1了, 所以在维护同一层的时候是不是有一条后面的必须<前面的才要, 比如在0, 1已经确定的这一层, 3, 2, 3, 这个2是值得一试的
- 这里说错了, 应该维护一个最小值,(大于已选择元素的最小值), 如果已经有1了, 大于1的就算了, 如果有个0.5就可以再试试, 没准有最优解
- 接下来确定回溯参数, start是需要的, 一个选中了只能从它后面选
- 其次是最终的结果, 这个可以维护个全局的, 也可以一直传递, res
- 终止条件是什么呢, 没有显示的终止条件, 只有尽力剪枝, 让整个过程短一点
```go
var res int
var cnt int

func lengthOfLIS(nums []int) int {
    backtrace(nums, 0)
    return res
}

func backtrace(nums []int, start int) {
    min := math.MaxInt64
    for i := start; i < len(nums); i++ {
        // 已经选了x, 下一个数比x小的就不要了
        if start > 0 && nums[i] <= nums[start - 1] {
            continue
        }
        // 维护一个前面遍历过的最小值
        // 比如已经选了0, 现在在 1, 0, 3, 2, 3中选, 前面如果已经有1备选, 3,2,3就不用尝试了
        // 因为0, 1, 3一定优于0,3
        if nums[i] < min {
            min = nums[i]
        } else {
            continue
        }
        cnt++
        if cnt > res {
            res = cnt
        }
        backtrace(nums, i + 1)
        cnt--
    }
}
[7,7,7,7,7,7,7]
输出：4
预期结果：1
这个样例测试没问题, 但提交它非说我输出的是4
是用了全局变量的原因, 不知道提交之后的环境发生了什么, res和cnt用全局变量就结果错误
改回局部变量, 然后在函数内传递, 注意res是个int, 传递的时候希望共享一块内存, 要传指针
改完之后
37 / 54 个通过测试用例
状态：超出时间限制
提交时间：2 分钟前
最后执行的输入：
[-147,-171,-584,590,501,13,489,-938,396,-544,-229,697,157,-933,-264,-436,-691,-469,49,-574,694,50,672,-858,-923,974,-157,-507,-907,429,529,-591,802,-351,-606,296,-485,454,540,300,-1000,408,923,0,-975,-548,62,-990,835,650,733,-611,-385,-580,330,394,566,-191,612,-608,-478,-104,-425,58,-849,601,851,-208,-810,400,412,571,-535,-995,627,-481,-702,457,-29,375,792,-186,-921,-275,654,-356,-322,-28,-843,527,-266,-970,556,852,-890,169,-413,2,-958,-651,371,895,-994,671,243,-605,-556,735,-246,179,-104,-771,658,-554,932,-829,-455,-981,-731,-148,512,-547,-946,-997,-197,864,870,629,-961,659,574,543,-501,582,-799,-428,876,-334,115,759,197,-905,275,76,242,357,694,-254,-361,-338,-57,596,786,-710,-51,-496,-100,246,-969,874,504,938,931,-365,175,-40,-616,596,440,567,999,15,-363,-256,-578,-869,-653,78,-352,882,749,-33,462,-592,-751,761,-96,206,489,34,367,960,68,837,37,-764,-897,72,639,-69,353,836,-67,491,126,-171,-532,-757,-358,217,806,712,-32,843,-790,-691,-381,-138,6,-712,153,-184,-544,3,840,-561,917,-704,-126,-230,468,963,-993,445,-892,-543,941,-665,58,268,-362,181,-529,684,313,-380,-712,700,601,-962,-886,702,439,153,-87,140,583,-323,70,-460,-863,-859,-784,571,169,44,-460,181,883,600,982,-367,-191,815,-84,961,-791,-713,149,-499,330,-351,-442,-989,-662,-183,-220,-617,-638,-916,454,604,559,-304,-812,526,-891,984,-762,-669,-414,-481,-219,-776,690,-72,-250,-282,-961]
果然回溯超时了, 学一下其他方法吧
```

## 看题解
- 回溯不行了, 原来是通过动态规划做, 回溯就是暴力搜索, 动态规划是规模更小的子问题还是这种问题
- 维护一个dp表, dp[i]表示以i位置结尾的最长子序列
- 每次计算dp[i], 变量j从[0, i-1]开始遍历一遍, 如果i位置的值比j位置的大, 则dp[i] = dp[j] + 1
- 原来如此, 好题好题
```go
func lengthOfLIS(nums []int) int {
    n := len(nums)
    dp := make([]int, n)
    res := 0
    for i := 0; i < n; i++ {
        dp[i] = 1
        for j := 0; j < i; j++ {
            if nums[i] > nums[j] {
                dp[i] = max(dp[i], dp[j] + 1)
            }
        }
        res = max(res, dp[i])
    }
    return res
}

func max(i, j int) int {
    if i < j {
        return j
    } else {
        return i
    }
}
```

