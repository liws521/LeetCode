https://leetcode-cn.com/problems/integer-break/

```java
class Solution {
    public int integerBreak(int n) {
        int[] dp;
        if (n < 7) {
            dp = new int[7];
        }
        else {
            dp = new int[n + 1];
        }
        dp[2] = 1; dp[3] = 2; dp[4] = 4; dp[5] = 6; dp[6] = 9;
        for (int i = 7; i <= n; i++) {
            dp[i] = Math.max(2 * dp[i - 2], 3 * dp[i - 3]);
        }
        return dp[n];
    }
}
/*
找规律吧
0,1不考虑
2 = 1 + 1, dp[2] = 1
3 = 1 + 2, dp[3] = 2
4 = 1 + 3 = 2 + 2, dp[4] = 4
5 = 1 + 4 = 2 + 3, dp[5] = 6
6 = 1 + 5 = 3 + 3 = 2 + 4 = 2 + 2 + 2, dp[6] = 9
7 = ?
当数值太小的时候分成3个数及以上没有什么意义,只有分出来的至少是2才有增益
一直到dp[6]是如何运用到前面的都没什么明显规律,由平均不等式我们知道6肯定平均分才能收益最大
但是不是只能分成两个数,当数的数量多了以后,二元的平均不等式没有太大意义
还是要找到dp之间的规律
e.g. 7 = 1 + 6, 就是1*dp[6], 7 = 2 + 5,dp[5]存储着相加为5的最大乘积,那么2*dp[5]就是这条路的答案,3*dp[4],等同理
但6的时候好特殊啊, dp[3] < 3, 导致3 * dp3的收益还不如 3 * 3, 2和3是比较特殊的,dp[i] < i
dp[10] = Math.max(1 * dp9, 2 * dp8, 3 * dp7, 4 * dp6, 5 * dp5, 6 * dp4, 7 * dp3, ...)
难道n就需要n项来比较么?
dp[7] = 12, dp[8] = 18, dp[9] = 27, dp[10] = 36
因为从4开始,dp[i]就>=i了
所以如果我想算dp[100], = Math.max(1 * dp[99], 2 * dp[98], 3 * dp[97], 4 * dp[96], 5 * dp[95]),
从把100拆成5和一堆组成95的数就不合算了,因为dp[5]>5,所以把5拆成更小的数字必然更合算,
明白了这个原理后再回头看等于时的4,dp[4]=4,所以能用4*dp[96]解决的必然能用2*2*dp[96]解决,这种case必然包含在2*dp[98]中了
由此我们知道,往前看2和3的拆分就可以了,至于1,你懂的,垃圾
dp[2] = 1;
dp[3] = 2;
dp[i] = Math.max(2 * dp[i - 2], 3 * dp[i - 3])
为什么写成这种格式,但它不是个通式呢,因为dp就默认至少拆成2个数,这个通式在默认至少拆成3个数,
由平均不等式我们知道,拆成两个数时的乘积最大为 i/2 * i/2
这是偶数的情况,当奇数的时候为 i/2 * (i/2 + 1),当然,在i>6之后,就基本上是拆成3个数及以上更划算了
*/
```