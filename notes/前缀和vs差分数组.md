前缀和
===

## 前缀和简介
- 前缀和的概念: 数组该位置之前的元素之和
- 进行前缀和运算时, 设sum[0] = 0, 下标从1开始运算
- 例如一个一维数组a = [1, 2, 3, 4, 5]
    - 前缀和sum = [0, 1, 3, 6, 10, 15], 求原数组[1, 3)的和, 就用sum[3] - sum[1]
    - 因为sum[3]表示[0, 3)的和, sum[1]表示[0, 1)的和, 两者之差就是区间[1, 3)
    - 半闭半开, 才是最优美的形式, 牛呀
- 前缀和的作用, 快速求出某段区间的和

## 二维数组的前缀和
```go
原数组如下
    0   1   2   3   4
0   1   2   3   4   5
1   2   2   1   1   2
2   3   1   3   1   3
3   1   2   3   1   2
4   2   1   1   1   1
这是一个5*5的二维数组, 最上一排和最左一排为下标, 
前缀和数组sum创建6*6的空间,
if i == 0 || j == 0 {
    sum[i][j] = 0
} else {
    sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + a[i - 1][j - 1]
}
0   0   0   0   0   0
0   1   3   6   10  15
0   3   7   11  16  23
0   6   11  18  24  34
0   7   14  24  31  43
0   9   17  28  36  49
比如我想求从a[1][2]到a[3][3](inclusive)形成的这个3*2的矩形的元素和, 怎么求, 
仿照一维的情况先写成优美的半闭半开, 相当于要求a[1][2]到a[4][4](exclusive)构成的矩形
res = sum[4][4] - sum[4][2] - sum[1][4] + sum[1][2] = 10, 成功
```

差分
=== 

## 差分简介
- 差分的概念, 差分其实就是前缀和的逆运算
- 差分的作用, 如果对某个区间需要每个元素加上C, 则需要使用差分来减少时间复杂度
- 差分数组, 原数组的第一个元素落下来(其实是假装前面减了一个0), 后面的sub[i] = a[i] - a[i - 1]
- x是y的前缀和, y就是x的差分
- 核心操作, 将a[L ,R]全部加上C, 等价于sum[L] += C, sum[R+1] -= C
- 举个例子, a = [3, 1, 4, 2, 5, 6]
    - 差分数组, sub = [3, -2, 3, -2, 3, 1]
    - a[2, 5)都加上10, 得到a = [3, 1, 14, 12, 15, 6]
    - 差分数组, sub = [3, -2, 13, -2, 3, -9]
    - 可以看出sub[2] += 10, sub[5] -= 10
- 仍然是半闭半开, 优美如斯
## 二维数组的差分
- 对照一维, 用于在二维的某个矩形上同时加一个值C
```go
假设有一个二维数组, 5*5的, 左侧和上侧的0忽略
0   0   0   0   0   0
0   1   3   6   10  15
0   3   7   11  16  23
0   6   11  18  24  34
0   7   14  24  31  43
0   9   17  28  36  49
想把1,2到 4,4 (exclusive)的部分都加上100
先构造差分数组
sub[i][j] = a[i][j] - a[i-1][j] - a[i][j-1] + a[i-1][j-1], -1的位置假设是0
得到数组
    0   1   2   3   4
0   1   2   3   4   5
1   2   2   1   1   2
2   3   1   3   1   3
3   1   2   3   1   2
4   2   1   1   1   1
把所说的哪些位置加上100后
0   0   0   0       0       0
0   1   3   6       10      15
0   3   7   111     116     23
0   6   11  118     124     34
0   7   14  124     131     43
0   9   17  28      36      49
差分数组为
    0   1   2       3       4
0   1   2   3       4       5
1   2   2   101     1       -98
2   3   1   3       1       3
3   1   2   3       1       2
4   2   1   -99     1       101
可以看出原来维护一个矩形的数值变化, 比如一个m*n的小矩形, 全都加上一个C, 需要O(m*n)
通过差分数组, 只需要4次操作O(1)就可以维护出相同的状态
```




## resource
https://www.cnblogs.com/xbhog/p/14348830.html