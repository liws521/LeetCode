
- 存储方式
    - 基于指针/引用的二叉链式存储法
    - 基于数组的顺序存储法
        - 一般用来存储完全二叉树, 左子树2i, 右子树2i+1, 根i/2
        - 堆就是一种完全二叉树, 最常用的存储方式就是数组


## 层序遍历
https://www.programmercarl.com/0102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html
- 层序遍历就是把图论中的广度优先遍历应用在二叉树上


## 二叉搜索树(二叉查找树)
- 特点, 支持动态数据集合的快速插入删除查找操作
- 删除操作比较复杂
    - 假设要删除节点A, 它的父节点为F
    - A没有子节点, 直接把F指向A的指针置空
    - A只有一个子节点, 把F指向A的指针指向A的子节点
    - A由两个子节点, 找到A右子树的最小节点, 替换到A的位置, 删除这个最小节点
    - 还有一种比较取巧的方式是不做真正的删除动作, 直接将待删除结点标记为已删除, 这样的缺点是比较浪费内存空间
- 支持重复数据的二叉搜索树
    - 把相等结点当作放到右子树
    - 当查找该节点, 找到一个并不停止, 记录, 继续向右子树找直至叶子节点
    - 删除节点时先查找所有该值节点, 然后按原来同样的方式删除
- Hash表可以在O(1)插入删除查找, 为什么需要二叉搜索树呢?
    - Hash中的数据无序, 如果想按序输出需要做排序操作, 而二叉搜索树的中序遍历就是O(n)下的有序数据.
    - Hash有hash冲突, 性能不稳定, 平衡二叉搜索树性能稳定O(logn)

## 平衡二叉查找树, 以红黑树为例
- 平衡二叉树: 二叉树中任意一个节点的左右子树的高度相差不能大于1
- AVL树是一种高度平衡的二叉树, 所以查找的效率非常高, 但是为了维持这种高度的平衡, 付出了很多代价, 每次插入/删除就要做调整, 复杂且耗时. 所以对于插入/删除操作很频繁的数据, 用AVL树代价较高.
- 红黑树是近似平衡的, 所以在维护平衡的成本上比AVL树低, 且红黑树各种操作性能都比较稳定, 所以工程中比较常用.

## 红黑树(R-B Tree)
- 每个叶子节点都是黑色的空节点nil, 也就是叶子节点不存储数据
- 任何相邻节点不能同时为红色
- 每个节点从该节点到达其可到达的叶子节点的所有路径, 包含相同数量的黑色节点


- 用递归树分析递归代码的时间复杂度
- 还有递推公式的方式分析